## Kubernetes 애플리케이션 기본 실행 명령어

### 쿠버네티스 버전확인
    kubectl version
(결과 예시)  
    Client Version: version.Info{Major:"1", Minor:"15", GitVersion:"v1.15.0", GitCommit:"e8462b5b5dc2584fdcd18e6bcfe9f1e4d970a529", GitTreeState:"clean", BuildDate:"2019-06-19T16:40:16Z", GoVersion:"go1.12.5", Compiler:"gc", Platform:"windows/amd64"}
    Server Version: version.Info{Major:"1", Minor:"15", GitVersion:"v1.15.0", GitCommit:"e8462b5b5dc2584fdcd18e6bcfe9f1e4d970a529", GitTreeState:"clean", BuildDate:"2019-06-19T16:32:14Z", GoVersion:"go1.12.5", Compiler:"gc", Platform:"linux/amd64"}  

⇒ 결과화면 내용중에 아래와 같이 Client Version과 Server Version버전을 볼수 있으면 2가지 버전이 틀리면 쿠버네티스 일부 명령옵션이 정상적으로 동작하지 않을 수 있음.  
  -Client Version: version.Info{Major:"1", Minor:"15"  
  -Server Version: version.Info{Major:"1", Minor:"15"  

### 1) Pod 생성
> kubectl run <파드명> --image=<ACCUNT-ID/IMAGE:TAG> --port=8080 [--generator=run/v1]

    kubectl run web --image=abc/nginx --port=8080
⇒ --generator=run/v1: 개발 테스트시만 사용, 복제 컨트롤러를 사용하여 파드를 생성, 생략시  디폴로이먼트 오브젝트로 생성됨

[kubernetes공식문서 가이드](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#run)
> $ run NAME --image=image [--env="key=value"] [--port=port] [--replicas=replicas] [--dry-run=bool] [--overrides=inline-json] [--command] -- [COMMAND] [args...]

    kubectl run nginx --image=nginx



### 2) Pod 확인

#### Pod 목록조회
    kubectl get pods
<
    NAME                  READY   STATUS      RESTARTS   AGE  
    sample-44pmh          0/1     Running     1          2d   
⇒(참고) ready 에서 0/1의 의미는 1개 준비 상태이며 실행대기상태

#### Pod 상세보기
    kubectl get pods -o wide
---------------------------------------------------------------------------------------------
    NAME             READY     STATUS    RESTARTS   AGE       IP           NODE  
    sample-app-ddjxr   1/1       Running   0          2m        172.17.0.6   minikube  

#### 실행중인 Pod 정의 확인
> kubectl get pods <파드명> -o yml

    kubectl get pods sample-pod -o yml
⇒(참고) 옵션 중 yml이 window os에서 error발생시 yaml로 지정, 또한 json으로도 가능

### 3) 레플리케이션 컨트롤러 확인

#### 목록조회
    kubectl get replicationcontrollers    
⇒(참고) replicationcontrollers는 축약어로 rc로 표기 가능  

---------------------------------------------------------------------------------------
    NAME       DESIRED   CURRENT   READY     AGE
    sample-app   1         1         1         3m

#### 상세조회
    kubectl get rc -o wide
---------------------------------------------------------------------------------------------------------------
    NAME        DESIRED   CURRENT   READY     AGE       CONTAINERS   IMAGES                 SELECTOR
    sample-app  1         1         1         3m        sample-app   dj/sample:latest   run=sample-app


### 4) 서비스 생성

> kubectl expose <CONTROLLER_TYPE> <RESOURCE> [--type=SVC_TYPE] --name <NAME>

    kubectl expose replicationcontroller sample-app <--type=LoadBalancer> --name sample-svc


### 5) 서비스 확인

    kubectl get services

⇒ (참고) EXTERNAL-IP는 minikube 사용시에는 외부 로드밸런서 없어서 pending 상태로 IP가 부여되질 않음( minikube tunnel 명령으로 참고)


### 6) 서비스 접근

    curl http://ip주소:8080

⇒ 서비스 확인시 EXTERNAL-IP 주소와, POTS확인 후 접속


### 7) 파드 스케일링

> kubectl scale replicationcontroller <파드명> --replicas=3

    kubectl scale replicationcontroller sample-app --replicas=3

sample-app 컨트롤러에게 3개의 파드 복제 관리하도록…  


### 8) 스케일링 결과 확인

    kubectl get pods

sample-app-**** 3개 목록이 생성된 것을 확인, 이때 파드이름의 -*** 는 쿠버네티스 컨트롤러에서 자동으로 부여함.

    kubectl get replicationcontrollers

NAME           DESIRED     CURRENT    READY    AGE

sample-app   3                   3                    3              10m

⇒ 애플리케이션 컨트롤러의 파드 생성 날짜 및 상태를 확인 가능


### 9) 서비스 요청 시 분산된 접근 확인

    curl http://ip주소:8080
    curl http://ip주소:8080
    curl http://ip주소:8080

⇒ 접속시 마다 다른 파드 컨테이너에  분산되는 것을 확인



### 10) 생성한 오브젝트 삭제

(1) 생성한 오브젝트 확인

    kubectl get all


(2) 서비스 삭제

> kubectl delete service <서비스명>


(3) 레플리케이션 컨트롤러 삭제

> kubectl delete reclicationcontrollers <레플리케이션컨트롤러명>


(4) Pod삭제

⇒ 레플리케이션 컨트롤러에서 관리되는 pod는 해당 컨트롤러 삭제시 삭제됨


(5) 삭제 여부 확인

    kubectl get all
    
