## Kubernetes 애플리케이션 기본 실행 명령어

### 쿠버네티스 버전확인
    kubectl version
(결과 예시)  
    Client Version: version.Info{Major:"1", Minor:"15", GitVersion:"v1.15.0", GitCommit:"e8462b5b5dc2584fdcd18e6bcfe9f1e4d970a529", GitTreeState:"clean", BuildDate:"2019-06-19T16:40:16Z", GoVersion:"go1.12.5", Compiler:"gc", Platform:"windows/amd64"}
    Server Version: version.Info{Major:"1", Minor:"15", GitVersion:"v1.15.0", GitCommit:"e8462b5b5dc2584fdcd18e6bcfe9f1e4d970a529", GitTreeState:"clean", BuildDate:"2019-06-19T16:32:14Z", GoVersion:"go1.12.5", Compiler:"gc", Platform:"linux/amd64"}  

⇒ 결과화면 내용중에 아래와 같이 Client Version과 Server Version버전을 볼수 있으면 2가지 버전이 틀리면 쿠버네티스 일부 명령옵션이 정상적으로 동작하지 않을 수 있음.  
  -Client Version: version.Info{Major:"1", Minor:"15"  
  -Server Version: version.Info{Major:"1", Minor:"15"  

### 1) Pod 생성
> kubectl run <파드명> --image=<ACCUNT-ID/IMAGE:TAG> --port=8080 [--generator=run/v1]

    kubectl run web --image=abc/nginx --port=8080
⇒ --generator=run/v1: 개발 테스트시만 사용, 복제 컨트롤러를 사용하여 파드를 생성, 생략시  디폴로이먼트 오브젝트로 생성됨

[kubernetes공식문서 가이드](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#run)
> $ run NAME --image=image [--env="key=value"] [--port=port] [--replicas=replicas] [--dry-run=bool] [--overrides=inline-json] [--command] -- [COMMAND] [args...]

    kubectl run nginx --image=nginx



### 2) Pod 확인

#### Pod 목록조회
> kubectl get pods [파드이름|NAMESPASE..]
⇒ 옵션값은 파드이름 뿐만 아니라 다양하게 지정가능 

    kubectl get pods
    
    (결과)------------------------------------------------------
    NAME                  READY   STATUS      RESTARTS   AGE  
    sample-44pmh          0/1     Running     1          2d   
⇒(참고) ready 에서 0/1의 의미는 1개 중 0개 준비 상태이임, 조회 옵션 파드를 지정하질 않으면 모든 파드목록을 조회함.

#### Pod 상세보기
    kubectl get pods -o wide
    
    (결과)--------------------------------------------------------------------------------
    NAME             READY     STATUS    RESTARTS   AGE       IP           NODE  
    sample-app-ddjxr   1/1       Running   0          2m        172.17.0.6   minikube  

#### Pod 정의 확인
> kubectl get pods <파드명> -o yml

    kubectl get pods sample-pod -o yml
⇒(참고) 옵션 중 yml이 window os에서 error발생시 yaml로 지정, 또한 json으로도 가능

    (샘플)-----------------------------------------------------------------------------
    apiVersion: v1
    kind: Pod
    metadata:
      creationTimestamp: "2019-07-17T04:43:05Z"
      labels:
        app: sample
      name: sample-44pmh
      namespace: default
      ownerReferences:
      - apiVersion: apps/v1
        blockOwnerDeletion: true
        controller: true
        kind: ReplicaSet
        name: cccr
        uid: 81682395-a5ce-4df8-b6c9-2f9d5c590a37
      resourceVersion: "121627"
      selfLink: /api/v1/namespaces/default/pods/sample-44pmh
      uid: 44f87fff-ab32-4af0-8527-4e227a25323d
    spec:
      containers:
      - image: dj/nginx
        imagePullPolicy: Always
        name: sample
        ports:
        - containerPort: 8080
          protocol: TCP
        readinessProbe:
          exec:
            command:
            - ls
            - /var/ready
          failureThreshold:
      -- 중략 --      

### 3) 레플리케이션 컨트롤러 확인

#### 목록조회
    kubectl get replicationcontrollers    
⇒(참고) replicationcontrollers는 축약어로 rc로 표기 가능  

    (결과)----------------------------------------------
    NAME         DESIRED   CURRENT   READY     AGE
    sample-app   1         1         1         3m

#### 상세조회
    kubectl get rc -o wide

    (결과)------------------------------------------------------------------------------------------------
    NAME        DESIRED   CURRENT   READY     AGE       CONTAINERS   IMAGES             SELECTOR
    sample-app  1         1         1         3m        sample-app   dj/sample:latest   run=sample-app


### 4) 서비스 생성

> kubectl expose <CONTROLLER_TYPE> <RESOURCE> [--type=SVC_TYPE] --name <NAME>

    kubectl expose replicationcontroller sample-app <--type=LoadBalancer> --name sample-svc


### 5) 서비스 확인

    kubectl get services
⇒ (참고) EXTERNAL-IP는 minikube 사용시에는 외부 로드밸런서 없어서 pending 상태로 IP가 부여되질 않음( minikube tunnel 명령으로 참고)

    (샘플) --------------------------------------------------------------------------
    NAME              TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
    sample            ClusterIP   10.109.218.253   <none>        80/TCP         2d1h
    sample-fortune    ClusterIP   10.103.14.83     <none>        80/TCP         2d
    sample-headless   ClusterIP   None             <none>        80/TCP         2d
    sample-hostpath   ClusterIP   10.98.48.213     <none>        80/TCP         2d
    sample-nfs        ClusterIP   10.96.115.107    <none>        80/TCP         46h
    sample-nodeport   NodePort    10.105.98.231    <none>        80:31111/TCP   2d3h
    kubernetes        ClusterIP   10.96.0.1        <none>        443/TCP        4d3h


### 6) 서비스 접근

    curl http://ip주소:8080

⇒ 서비스 확인시 EXTERNAL-IP 주소와, PORT확인 후 접속


### 7) 파드 스케일링

> kubectl scale replicationcontroller <파드명> --replicas=3

    kubectl scale replicationcontroller sample-app --replicas=3

sample-app 컨트롤러에게 3개의 파드 복제 관리하도록…  


### 8) 스케일링 결과 확인

    kubectl get pods

sample-app-**** 3개 목록이 생성된 것을 확인, 이때 파드이름의 -*** 는 쿠버네티스 컨트롤러에서 자동으로 부여함.

    kubectl get replicationcontrollers

    (샘플)--------------------------------------------------------------------------------------------
    NAME           DESIRED     CURRENT    READY    AGE

    sample-app    3            3          3        10m

⇒ 애플리케이션 컨트롤러의 파드 생성 날짜 및 상태를 확인 가능


### 9) 서비스 요청 시 분산된 접근 확인

    curl http://ip주소:8080
    curl http://ip주소:8080
    curl http://ip주소:8080

⇒ 접속시 마다 다른 파드 컨테이너에  분산되는 것을 확인



### 10) 생성한 오브젝트 삭제

(1) 생성한 오브젝트 확인

    kubectl get all


(2) 서비스 삭제

> kubectl delete service <서비스명>
    kubectl delete service sample-svc


(3) 레플리케이션 컨트롤러 삭제

> kubectl delete reclicationcontrollers <레플리케이션컨트롤러명>
    kubectl delete rc sample-rc


(4) Pod삭제

⇒ 레플리케이션 컨트롤러에서 관리되는 pod는 해당 컨트롤러 삭제시 삭제됨


(5) 목록조회로 삭제 여부 확인

    kubectl get all
    
