#### 참고
#### minikube
단일 노드 K8S 클러스터로 여러분의 컴퓨터 상에서 로컬로 K8S를 구동하기 쉽도록 해준다. 
#### kubectl
K8S 노드와 소통하기 위한 kubectl을 설치하는 것



<hr/>



### kubectl version
    kubectl version
kubernetes서버 버전 확인  

Client Version: version.Info{Major:"1", Minor:"15", GitVersion:"v1.15.0", GitCommit:"e8462b5b5dc2584fdcd18e6bcfe9f1e4d970a529", GitTreeState:"clean", BuildDate:"2019-06-19T16:40:16Z", GoVersion:"go1.12.5", Compiler:"gc", Platform:"windows/amd64"}
Server Version: version.Info{Major:"1", Minor:"15", GitVersion:"v1.15.0", GitCommit:"e8462b5b5dc2584fdcd18e6bcfe9f1e4d970a529", GitTreeState:"clean", BuildDate:"2019-06-19T16:32:14Z", GoVersion:"go1.12.5", Compiler:"gc", Platform:"linux/amd64"}

위 Client Version과 Server Version일치 여부를 확인한다. 만약 틀릴경우 kubectl 일부 명령이 동작 하질 않을 수 있음  


### windows 환경에서 curl 명령어 확장
#### curl 7.65.1 for windows 설치
[crul설치(https://curl.haxx.se/windows/)(https://curl.haxx.se/windows)

curl 7.65.1 for windows.zip 다운후 사용자 홈디렉토리(예:C:\Users\사용자)에 압축해제 후 bin 폴더 안에 있는 파일 3개(curl.exe, curl-ca-bundle.crt, libcurl-x64.dll) 복사/붙이기 후 해당 폴더에서 아래 명령 실행
> ./curl



### 쿠번네티스의 클러스터 정보 확인
    kubectl cluster-info
dump상세정보확인
    kubectl cluster-info dump
  
### 쿠버네티스의 노드 정보 확인
    kubectl get nodes
자세한 정보
    kubectl get nodes -o wide
  
### 애드온
#### 클러스터 DNS:
  kube-dns: 쿠버테니스 내부에서만 사용(필수)
  
#### 컨테이너 리소스 모니터링:  
프로메테우스 외부 프로젝트 많이 사용
  
### 클러스터에서 지원하는 API 버전확인(alpha정보제외)
    kubectl api-versions
    
### API 리소스 확인
    kubectl api-resources
    
    
    
<hr/>

    
## YAML 및 오브젝트
### YAML
YAML Ain't Markup Language(YAML은 마크업 언어가 아니다)라는 재귀적인 이름에서 유래...
(중요) YAML에서는 tab키를 인식하질 않는다.(사용x)
들여쓰기는 보통 2칸으로 사용  
[YAML(https://yaml.org)](https://yaml.org/)

스칼라/스트링, 리스트/어레이, 해시/딕셔너리 3가지 많이 사용.

#### (1) 스칼라/스트링
-단순 간단한 문자 또는 문자열
-쌍/홑 따옴표를 사용하여 둘러쌀 수 있으나 일반적으로 사용하질 않는다.
-한줄에 하나의 문자열이다.
-순서가 없다.  

#### (2) 리스트/어레이
-스칼라 앞에 '-'을 붙이고 '-' 와 문자 사이는 공백이 있어야 한다.
 ==> - abc  
-리스트는 순서가 있다.
-한 줄에 하나의 요소를 표현  

#### (3) 해시/딕셔너리
- key: value 형태, 이때 주의 할 점은 value 앞은 공백으로 띄워쓰기 필수
 ==> 예) name: 홍길동  

#### (4) 해시의 리스트

#### (5) 리스트의 해시

### YAML 문법
-YAML 문자열은 UTF-8 또는 UTF-16의 유니코드 문자집합 사용  
(참고) 유닉스에서 줄바꿈(개행)을 CRLF를 인식못하고 LF만 인식함  
-공백문자를 이용하여 들어쓰기(tab들어쓰기 사용하질 않음)  
-하나의 스트림에 있는 여러 개의 YAML 문서를 구분하기 위해  
 시작은 하이픈 3개(---), 끝은 마침표 3개(...)를 사용  
-주석은 #으로 표시, 한 줄이 끝날 때까지 유효
-YAML 파일릐 확장자는 yml 또는 yaml  

    apiVersion: v1
    kind: pod
    metadata:
      name: myapp-pod
      lables:
        app: myapp
        type: frontend
    spec:
      containers:
        - name: nginx-container
          image: nginx
필수 필드:  
-apiVersion: 오브젝트를 생성하기 위한 API버전(2019.97월 기준 현재 v1만 존재)
==> kubectl api-versions 명령결과에서 앞에 그룹이 없는 것만 사용가능
-kind: 오브젝트 종류(pod, services, replcaset, deployment 등등)  
-metadata: name, UID, namespace 등을 포함하는 기본적인 정보  
-spec: 오브젝트의 상태 정의, 정의할 요소는 정의하고자 하는 오브젝트의 종류에 따라 다름  

<hr/>

### Visual Studio Code 설정
setting: eol검색..에서 \n으로 설정
Extenstion 설치: yaml, kubernets

<hr/>

### 오브젝트(Pod) 생성 
    kubectl run cccr-app --image=ons/cccr:latest --port=8080 --generator=run/v1
--generator=run commond옵션은 pod를 생성하겠다는 의미

### Pod 보기
    kubectl get pods

    결과화면 예시---------------------------------------------------------------------------  
    NAME             READY     STATUS    RESTARTS   AGE  
    cccr-app-ddjxr   1/1       Running   0          57s  
    ---------------------------------------------------------------------------------------  
==> ready 에서 1/1의 의미는 1개 준비 상태에 / 1개가 실행됨


### Pod 상세보기
    kubectl get pods -o wide
 
    결과화면 예시----------------------------------------------------------------------------  
    NAME             READY     STATUS    RESTARTS   AGE       IP           NODE  
    cccr-app-ddjxr   1/1       Running   0          2m        172.17.0.6   minikube  
    ---------------------------------------------------------------------------------------  

https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/

    kubectl get rc
    kubectl get replicationcontroller
    
    ==> rc: replicationcontroller의 약어

    결과화면 예시----------------------------------------------------------------------------  
    NAME       DESIRED   CURRENT   READY     AGE  
    cccr-app   1         1         1         3m  
    ---------------------------------------------------------------------------------------    

#### replicationcontroller 상세보기
    kubectl get rc -o wide
    
    ------------------------------------------------------------------------------------------------------  
    NAME       DESIRED   CURRENT   READY     AGE       CONTAINERS   IMAGES            SELECTOR  
    cccr-app   1         1         1         3m        cccr-app     ons/cccr:latest   run=cccr-app  
    ------------------------------------------------------------------------------------------------------  

### 오브젝트(Pod) 삭제
    kubectl delete pod cccr-app-ddjxr
결과메시지: pod "cccr-app-ddjxr" deleted

    kubectl get po
    
    -------------------------------------------------------  
    NAME             READY     STATUS    RESTARTS   AGE  
    cccr-app-956n6   1/1       Running   0          38s  
    -------------------------------------------------------  
kubectl delete pod cccr-app-ddjxr로 삭제해도 pod는 무조건 1개를 생성함.

#### --watch command
1초마다 실시간 보기

1. 레플리케이션컨트롤 상태보기  

    kubectl get rc --watch
    
2. pod 상태보기 

    kubectl get ps --watch


3. 리눅스 명령어로 실시간 보기

    -- pod보기 --
    while (1) {kubectl get po ; start-sleep -seconds: 1; clear}
    -- replicationcontroller보기 --    
    while (1) {kubectl get rc ; start-sleep -seconds: 1; clear}
    -- 서비스보기 --
    while (1) {kubectl get svc ; start-sleep -seconds: 1; clear}


#### replicationcontroller 상태보기
    kubectl get rc --watch
    
#### Pod 상태보기
    kubectl get ps --watch

### 서비스 생성
    kubectl expose rc cccr-app --type=LoadBalancer --name=cccr-svc
결과화면: service "cccr-svc" exposed


### 서비스 확인
    kubectl get services
    
    ------------------------------------------------------------------------------------  
    NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE  
    cccr-svc     LoadBalancer   10.100.20.190   <pending>     8080:32559/TCP   27s  
    kubernetes   ClusterIP      10.96.0.1       <none>        443/TCP          1d  
    ------------------------------------------------------------------------------------  
    
#### (1) minikube tunnel    
EXTERNAL-IP pending 상태인데 이는 클라우드 환경 외부 로드밸런서가 없어서 외부 IP를 얻지 못하기 때문
minikube에서는 아래 명령으로 사용하면 됨.

    minikube.exe tunnel
    
⇒ 실행시 error발생 하질 않아야 services에 EXTERNAL-IP 부여 됨.
⇒ 실행시 error발생시 서비스 외부 IP가 없어서 테스트 미지원

    
#### (2) minikube service 서비스명  
위 명령 minikube tunnel error발생으로 curl 테스트 불가시 아래 명령으로 실행후 IP, PORT정보 확인 후 브라우져 확인

    minikube.exe service list  

    |-------------|------------|-----------------------------|  
    |  NAMESPACE  |    NAME    |             URL             |  
    |-------------|------------|-----------------------------|  
    | default     | cccr-svc   | http://192.168.99.100:32559 |  
    | default     | kubernetes | No node port                |  
    | kube-system | kube-dns   | No node port                |  
    |-------------|------------|-----------------------------|  

위 서비스 목록에서 Name확인 후 지정

    minikube.exe service cccr-svc
    
    결과메시지: 
    Opening kubernetes service default/cccr-svc in default browser...

⇒ 자동으로 기본 브라우져가 실행되면서 접속(참고: ms ie 브라우져에서 열리질 않을 경우 Chrome 브라우져에서 확인)
⇒ 또는 service list 항목에서 해당 서비스의 URL정보를 직접 브라우져에 입력 후 접속

### Pod 스케일링
    
    kubectl scale rc cccr-app --replicas=3
    
    결과메시지: replicationcontroller "cccr-app" scaled

위 Pod 스케일링시 실시간 모니터링 상태를 띄운상태로 확인 가능  
-아래 watch로 보면 pod 스케일링 상태 보임.  

    kubectl get rc --watch <== replicationcontroller 상태보기
    kubectl get ps --watch <== pod 상태보기 

### 생성된 오브젝트 삭제

#### service 삭제
    kubectl delete service cccr-svc
    
    결과메시지: service "cccr-svc" deleted

#### Pod 삭제
    kubectl delete pod cccr-pod

⇒ 위 pod를 삭제해도 계속 생성됨 그래서 아래 리플리케이션컨트롤을 삭제함.

    kubectl delete rc cccr-app

### replicationcontroller(rc) 삭제확인 

    kubectl get rc
    kubectl get pods

위 Pod cccr-app 삭제 확이됨.

### 오브젝트 확인
    kubectl get pods


<hr/>



## 워크로드 파드

### 파드정의(YAML문서작성)
YAML 작성: 파드를 생성할 수 있는 YAML(yml) 파일 작성

    cccr-pod.yml
        apiVersion: v1
        kind: Pod
        metadata:
          name: cccr-pod
        spec:
          containers:
          - image: c1t1d0s7/cccr
            name: cccr
            ports:
            - containerPort: 8080
              protocol: TCP
              
(참고) 오브젝트 리소스의 API확인: kubectl api-resources (<== kubectl explain)
    NAME                              SHORTNAMES   APIGROUP                       NAMESPACED   KIND
    bindings                                                                      true         Binding
    componentstatuses                 cs                                          false        ComponentStatus
    configmaps                        cm                                          true         ConfigMap
    endpoints                         ep                                          true         Endpoints
    events                            ev                                          true         Event
    limitranges                       limits                                      true         LimitRange
    namespaces                        ns                                          false        Namespace
    nodes                             no                                          false        Node
    --중략--

 
### 파드생성
    kubectl create -f cccr-pod.yml
결과메시지: pod/ccr-pod created
 
### 파드 목록 확인
    kubectl get pods

### 실행중인 파드이 정의 확인
    kubectl get pods cccr-pod -o yml

⇒ (참고) yml 지정으로 error 발생시 yaml 또는 json


### 파드의 자세한 정보 확인
    kubectl describe pods cccr-pod

### 파드 로그 확인
> kubectl logs <파드명>

    kubectl logs cccr-pod

다중 컨테이너를 가지고 있는 경우 -c옵션을 사용하여 컨테이너(cccr)를 지정
> kubectl logs <파드명> -c <컨테이너명>

    kubectl logs cccr-pod -c cccr


### 파드 포트 포워딩
    kubectl port-forward cccr-pod 80:8080 <== 클라이언트(80):(pod:8080)
    Forwarding from 127.0.0.1:8080 -> 80
    Forwarding from [::1]:8080 -> 80

확인은 : ./curl http://localhost
⇒ 80 prot는 생략 된 상태.
 


<hr/>
<br>

## label


### 라벨을 사용한 포드정의
cccr-pod-width-label.yml작성

#### 생성
    kubectl create -f cccr-pod-width-label.yml

### 파드의 라벨 확인

#### get pod --show-labels

    kubectl get po --show-labels
    
    (결과샘플)-------------------------------------------------------------------
    NAME                    READY   STATUS      RESTARTS   AGE    LABELS
    sample-44pmh            0/1     Running     1          2d3h   app=sample
    sample-77kcv            0/1     Running     1          2d3h   app=sample
    sample-arg-pod          1/1     Running     1          2d     <none>
    sample-comp             1/1     Running     1          47h    <none>
    sample-configmap-pod    1/1     Running     1          47h    <none>
    sample-env-pod          1/1     Running     1          47h    <none>
    requests-pod            1/1     Running     1          27h    <none>

#### get pod -L env

    kubectl get po -L env
    
    (결과샘플)-------------------------------------------------------------------
    NAME                    READY   STATUS      RESTARTS   AGE    ENV
    sample-44pmh            0/1     Running     1          2d3h
    sample-77kcv            0/1     Running     1          2d3h
    sample-arg-pod          1/1     Running     1          2d
    sample-comp             1/1     Running     1          47h
    sample-configmap-pod    1/1     Running     1          47h
    sample-env-pod          1/1     Running     1          47h
    requests-pod            1/1     Running     1          27h

#### get pod -L env,tier
    kebuctl get po -L env,tier
    
    (결과샘플)-------------------------------------------------------------------
    NAME                    READY   STATUS      RESTARTS   AGE    ENV    TIER
    sample-44pmh            0/1     Running     1          2d3h
    sample-77kcv            0/1     Running     1          2d3h
    sample-arg-pod          1/1     Running     1          2d
    sample-comp             1/1     Running     1          47h
    sample-configmap-pod    1/1     Running     1          47h
    sample-env-pod          1/1     Running     1          47h
    requests-pod            1/1     Running     1          27h

#### pods (cccr-label-pod) -o yml
    kubectl get pods cccr-label-pod -o yml(yaml)
    
    (결과샘플)-------------------------------------------------------------------
    apiVersion: v1
    kind: Pod
    metadata:
      creationTimestamp: "2019-07-17T04:43:05Z"
      generateName: cccr-
      labels:
        app: cccr
      name: cccr-44pmh
      namespace: default
      ownerReferences:
      - apiVersion: apps/v1
        blockOwnerDeletion: true
        controller: true
        kind: ReplicaSet
        name: cccr
        uid: 81682395-a5ce-4df8-b6c9-2f9d5c590a37
      resourceVersion: "121627"
      selfLink: /api/v1/namespaces/default/pods/cccr-44pmh
      uid: 44f87fff-ab32-4af0-8527-4e227a25323d
    spec:
      containers:
      - image: c1t1d0s7/cccr
        imagePullPolicy: Always
        name: cccr
        ports:
        - containerPort: 8080
          protocol: TCP
        readinessProbe:
            --중략--


#### pods (cccr-label-pod) -o json

    kubectl get pods cccr-label-pod -o json
    
    (결과샘플)-------------------------------------------------------------------
    {
    "apiVersion": "v1",
    "kind": "Pod",
    "metadata": {
        "creationTimestamp": "2019-07-17T04:43:05Z",
        "generateName": "cccr-",
        "labels": {
            "app": "cccr"
        },
        "name": "cccr-44pmh",
        "namespace": "default",
        "ownerReferences": [
            {
                "apiVersion": "apps/v1",
                "blockOwnerDeletion": true,
                "controller": true,
                "kind": "ReplicaSet",
                "name": "cccr",
                "uid": "81682395-a5ce-4df8-b6c9-2f9d5c590a37"
            }
        ],
        "resourceVersion": "121627",
        "selfLink": "/api/v1/namespaces/default/pods/cccr-44pmh",
        "uid": "44f87fff-ab32-4af0-8527-4e227a25323d"
    },
    "spec": {
        "containers": [
            {
                "image": "c1t1d0s7/cccr",
                "imagePullPolicy": "Always",
                "name": "cccr",
                "ports": [
        --중략--                


#### describe pod cccr-label-pod

    kubectl describe pod cccr-label-pod
    (결과샘플)-------------------------------------------------------------------
    Name:           cccr-label-pod
    Namespace:      default
    Priority:       0
    Node:           minikube/10.0.2.15
    Start Time:     Wed, 17 Jul 2019 13:43:05 +0900
    Labels:         app=cccr
    Annotations:    <none>
    Status:         Running
    IP:             172.17.0.10
    Controlled By:  ReplicaSet/cccr
    Containers:
      cccr:
        Container ID:   docker://aa82d4b5752ea50d4ab3d46bf99e17717065de391bd08e337e7bf833ac6ebd55
        Image:          c1t1d0s7/cccr
        Image ID:       docker-pullable://c1t1d0s7/cccr@sha256:0140ce4dcecc05fc52030970d0adad7ef04e8dac82957a938fe836ee63308710
        Port:           8080/TCP
        Host Port:      0/TCP
        State:          Running
          Started:      Fri, 19 Jul 2019 14:16:32 +0900
        Last State:     Terminated
          Reason:       Error
          Exit Code:    137
          Started:      Wed, 17 Jul 2019 13:43:11 +0900
          Finished:     Thu, 18 Jul 2019 15:23:13 +0900
        Ready:          False
        Restart Count:  1
        Readiness:      exec [ls /var/ready] delay=0s timeout=1s period=10s #success=1 #failure=3
        Environment:    <none>
        Mounts:
          /var/run/secrets/kubernetes.io/serviceaccount from default-token-fx2tj (ro)
    Conditions:
      Type              Status
      Initialized       True
      Ready             False
      ContainersReady   False
      PodScheduled      True
    Volumes:
      default-token-fx2tj:
        Type:        Secret (a volume populated by a Secret)
        SecretName:  default-token-fx2tj
        Optional:    false
    QoS Class:       BestEffort
    Node-Selectors:  <none>
    Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                     node.kubernetes.io/unreachable:NoExecute for 300s
    Events:
      Type     Reason     Age                     From               Message
      ----     ------     ----                    ----               -------
      Warning  Unhealthy  2m22s (x957 over 161m)  kubelet, minikube  Readiness probe failed: ls: cannot access '/var/ready': No such file or directory



### 라벨 수정
내용 입력하세요~~~


### 라벨 지우기
    kubectl label pods cccr-pod env=dev
    kubectl label pods cccr-label-pod env=debug

⇒ 위 실행시 에러발생:
error: 'env' already has a value(dev), and --overwrite is false  

    kubectl label pods cccr-label-pod env=debug --overwrite  


    kubectl label pods cccr-pod env- <==env뒤에 -를 붙이면 라벨이 지워짐
    kubectl get pod --show-labels
    kubectl label pods cccr-pod nev env=dev
    kubectl label pods cccr-pod ev-

### 검색
    kubectl get pods --show-labels -l tier 
    kubectl get pods --show-labels l env
    kubectl get pods --show-labels -l env,tier
    kubectl get pods --show-labels -l env,tiler,relaease
    kubectl get pods --show-labels -l '!env' <= env가 아닌것 검색
    kubectl get pods --show-labels -l 'ienv,!tier'


    kubectl delete pods -l 'env in (debug)'
⇒ pod중 label의 env중 debug를 삭제하라!!!

























<hr/>
<hr/>
<hr/>

## 어노테이션
주석이락도 함, 작성자 정보표기 등에 사용

    kubectl describe pods cccr-label-pod
    
⇒ 결과 내용중 'Annotations: ' 값이 있음

    kubectl annotate pods cccr-label-pod devops-team/developer="DJ"
    kubectl describe pods cccr-label-pod 로 확인 가능
⇒ Annotations:  devops-team/developer: DJ



## 네임스페이스
리소스(Pod 등) 를 논리적으로 오브젝트를 분리  
리소스를 볼수 있는 권한 을 제한하는 목적으로도 사용  

### 네임스페이스 확인
    kubectl get namespaces
⇒ namespaces 생략시  default로 사용됨

### 네임스페이스의 오브젝트 확인 
    kubectl get all <==전부
    kubectl get all -n kube-system <== kube-system의 전부
    kubectl get pod -n kube-sytem <== kube-system의 pod

    kubectl get pods -n default
    kubectl get pods -n kube-system
    kubectl get pods -n kube-node-lease
    kubectl get pods -n kube-public


    kubectl get pods --all-namespaces <== 모든 pod의 네임스페이스를 보기
    kubectl get service --all-namespaces <== 모든 service의 네임스페이스를 보기


### 네임스페이스 생성(명령어)
    kubectl create namespace development
    
### 확인
    kubectl get namespaces


### 네임스페이스 삭제
    kubectl delete pods cccr-pod <== 오브젝트 이름으로 파드 삭제
    kubectl delete -f qa-namespace.yml <==yaml파이로 삭제
    kubectl delete pods -l tier=fronted <== 오브젝트 라벨을 이용한 오브젝트 삭제

    kubectl delete ns development <==네임스페이스로 삭제
    kubectl delete namespace development
    kubectl delete ns kube-system




### 네임스페이스 생성(YAML)
    kubectl create -f qa-namespace.yml
    
    결과메시지: namespace/quality-assurance created


### 특정 네임스페이스에서 오브젝트 생성 

    kubectl create -f cccr-pod.yml -n development
    
    결과메시지: pod/cccr-pod created

    kubectl get pods -n development
    
    (결과샘플)--------------------------------------
    NAME       READY   STATUS    RESTARTS   AGE
    cccr-pod   1/1     Running   0          17s



































































































****** 워크로드 - 컨트롤러 ****************************************
1) 라이브니스 프로브 
livenessProbe:
==> 애플리케이션에서 문제가 발생했을 때 pod를 재시작 매커니즘 

* 정보확인
> kubectl explain pod.spec.containers.livenessProbe
>  kubectl explain pod.spec.containers.livenessProbe.httpGet <==httpGet확인

yml작성 후 
kubectl create -f cccr-liveness-pod.yml
kubectl describe pods cccr-liveness-pod
항목 중 Liveness: 확인
kubectl get pods --watch

유닉스 반복 명령어로 모니터일 : 
while (1) {kubectl get pods; start-sleep -seconds: 1; clear}

kubectl describe pods cccr-liveness-pod-404


initialDelaySeconds: 
이값은 애플리세이션 기동시간까지의 지연시간간 설정
이시간이 짧으면 애플리케이션이 비정장 적으로 restart됨.



2) 레플리케이션 컨트롤러(rc)
pod를 복제관리.
파드가 특정 개수만큼이 복제되고 동작하는 것을 보장
파드와 컨트롤러는 레이블로 연결됨.
* 레플리케이션 컨트롤러를 구성하는 3가지 요소
-라벨셀렉터: 파드를 지정하는 라벨셀렉터
-파드 템플릿: 새로운 파드의 복제본을 만들기 위한 파드 템플릿
-복제수 

kubectl get pod
kubetctl get pod,rc <==,로 구분시 여러개 resource 확인가능

kubectl get pod,rc --watch <실행시 여러개 리소스는 실시간 모니터링ㅇ 안됨
그래서
유닉스명령
while (1) {kubectl get pod,rc; start-sleep -seconds:1; clear}


*** 컨트롤러를 삭제하면 Pod로 같이 삭제됨.

kubectl get re cccr-abc -o yaml
kubectl edit <= default 편집기로 열림
저장후 가능하면 아래 명령실행 필요.
kubectl replace -f cccr-re~~~*.yml <= 이미 만들어진 파일을 수정



3) 레플리카셋
-레플리케이션 컨트롤러(rc)의 문제점 및 기능개선 기능으로 이것으로 사용함.
kubectl api-resources | findstr replicaset
-------------------------------------------------------
replicasets                       rs           apps                           true         ReplicaSet
replicasets                       rs           extensions                     true         ReplicaSet
-------------------------------------------------------
명령 결과에서 
(차목)
~1.5까지 extensions 관리하다가
1.6부터는 apps로 관리함
kubectl create cccr-pod-~~.yml

rs: replicaset
while (1) {kubectl get pod,rs; start-sleep -seconds:1; clear}


4) 데몬셋
kubectl get all -n kube-system
결과 중  daemonset .apps/kube-proxy 를....

보통 외부용 보다는 내부용 agent용으로 사용할때 사용함.
데몬셋은 복제본을 만드는 것으 아니다.

kubectl get nodes --show-labels

ds:asemonset
while (1) {kubectl get pod,ds; start-sleep -seconds:1; clear}

> kubectl label nodes minikube node=development



5) 잡

while (1) {kubectl get pod,job; start-sleep -seconds:1; clear}


6) 크론잡

while (1) {kubectl get pod,cronjob; start-sleep -seconds:1; clear}



***** 멀티 노드 테스트  ********************
minikube는 단일 노드 환경인데.. 멀티노드 환경 테스트 필요시는 아래 것으로 테스팅
kubespry를 권장

*kubeadm 으로...(minikube로 kubeadm으로 구성된 것임.)
https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/

복사/붙이기 ㅌ스트: 
https://raw.githubusercontent.com/c1t1d0s7/cccr-k8s/master/kubespray-Vagrantfile

*kubespray
강사 github: https://github.com/c1t1d0s7/cccr-k8s/blob/master/vagrant-README.md


https://kubernetes.io/docs/setup/production-environment/tools/kubespray/
==> Vagrant(https://www.vagrantup.com/) 사용법 설명

https://github.com/kubernetes-sigs/kubespray






3day======================================================

** 네트워크 **********************************************************
쿠버네티스를 설치하면 Calico 네트워크가 설치(https://docs.projectcalico.org/v2.0/getting-started/kubernetes/)


** 서비스 **************
> kubectl cluster-info dump | findstr cluster-ip
  "--service-cluster-ip-range=10.96.0.0/12",
==> 쿠버네티스의 Pod와 Service의 네트워크 정보

> kubectl get svc
서비스 확인


** 서비스 접극 테스트
> kubectl run nettool -it --image=praqma/network-multitool --generator=run-pod/v1 --rm=true bash
If you don't see a command prompt, try pressing enter.
bash-5.0#



**** 환경변수 탐색
kubectl exec cccr-****(파드명) env


** 서비스 탐색***********************************
-web <-> was <-> db 서비스 탐색 연결
--> 서비스 참조로 가능 
(2)DNS를 이용한 서비스 검색
> kubectl get all -n kube-system -l k8s-app=kube-dns
-----------------------------------------------------------------------------------------------
NAME                           READY   STATUS    RESTARTS   AGE
pod/coredns-5c98db65d4-4ntms   1/1     Running   5          47h
pod/coredns-5c98db65d4-7dql7   1/1     Running   5          47h


NAME               TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE
service/kube-dns   ClusterIP   10.96.0.10   <none>        53/UDP,53/TCP,9153/TCP   47h


NAME                      READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/coredns   2/2     2            2           47h

NAME                                 DESIRED   CURRENT   READY   AGE
replicaset.apps/coredns-5c98db65d4   2         2         2       47h
-----------------------------------------------------------------------------------------------
파드의 내부 DNS설정도 확인 가능
> kubectl exec cccr-ww444 cat /etc/resolv.conf
nameserver 10.96.0.10
search default.svc.cluster.local svc.cluster.local cluster.local
options ndots:5



3) 클러스터 외부 서비스

** NodePort : 외부 노출 port <====중요함, 설제 서비스 구현시 외부 노출용으로 할당...
동일 클러스터 port 저정됨으로 클라이언트로 NodeProt로 접근하면 동일한 서비스로 접그됨.
--> docker expose와 동일하다고 생각하면 됨

**외부용 DNS구성 개발시 참조 사이트 :
(참고-현재 구글에서 인큐베이팅(개발중)...) https://github.com/kubernetes-incubator/external-dns


while (1) {curl http://192.168.64.18:31111; start-sleep -seconds:1; clear}


** LoadBalancer : 외부 노출 로드밸런스
-EXTERNAL-IP가 유일하게 할당 됨.(클러스트 환경 동적 IP부여가 가능하면.. )
(참고-현재 beta)https://metallb.universe.tf/  <==외부 할당 IP테스트용

>>>> 클러스트가 있는 것 처럼 아래 명령을 실행 후 LoadBalancer의 EXTERNAL-IP가 할당된 것을 볼 수 있음.
> minikube tunnel




** 인그레스 *******************
>>>(참고) 실제 운영서비스에서는 yaml 개발이 필요

> minikube addons list
- addon-manager: enabled
- dashboard: disabled
- default-storageclass: enabled
- efk: disabled
- freshpod: disabled
- gvisor: disabled
- heapster: disabled
- ingress: disabled
- logviewer: disabled
- metrics-server: disabled
- nvidia-driver-installer: disabled
- nvidia-gpu-device-plugin: disabled
- registry: disabled
- registry-creds: disabled
- storage-provisioner: enabled
- storage-provisioner-gluster: disabled
위 내용 중 ingress: disabled을 enabled로 설정해야 함.

enable설정
minikube addons enable ingress
* ingress was successfully enabled
> minikube addons list
- ingress: enabled


>확인
> kubectl get all -n kube-system <== ingress할당되는 것을 확인 가능함
while (1) { kubectl get all -n kube-system; start-sleep -seconds:1; clear}

curl --resolve cccr.example.com:80:192.168.99.100 http://cccr.example.com
==> http://cccr.example.com로 접근시 cccr.example.com:80 > 192.168.99.100로 연결하라!!!!

**인그레스는 도메인이름으로만 접근 가능 IP로 안됨!!!!!


**인그레이스를 이용한 TLS종료 프록시 구셩
(기본 리눅스 환경에서 생성함, windows os은 openssl을 따로 설치함.)
(TLS 개인키 생성)
opensssl genrsa -out ingress-tls.key 2048 <== RSA 2048 키 길이 개인파일 생성
(인증서 생성)
openssl req -new -x509 -key ingress-tls.key -out imgress-tls.cert -days 3650 -subj /CN=cccr.example.com

(인증서 설치)
> kubectl create secret tls ingress-tls-secret --key=ingress-tls.key --cert=ingress-tls.cert
secret/ingress-tls-secret created

> kubectl get secret
NAME                  TYPE                                  DATA   AGE
default-token-fx2tj   kubernetes.io/service-account-token   3      2d1h
ingress-tls-secret    kubernetes.io/tls                     2      11s

> kubectl create -f cccr-tls-ingress.yml
ingress.extensions/cccr-tls-ingress created


> kubectl get ingresses.extensions
NAME               HOSTS              ADDRESS     PORTS     AGE
cccr-ingress       cccr.example.com   10.0.2.15   80        88m
cccr-tls-ingress   cccr.example.com   10.0.2.15   80, 443   37s

> minikube ssh 접속
> curl --resolve cccr.example.com;4443:192.168.9910 -k -v https://cccr.example.com



** 레디니스 프로브 ************
(레디니스 프로브 생성)
yml작성 후 생성
> kubectl create -f cccr-readiness-replicaset.yml -f cccr-svc.yml
replicaset.apps/cccr created
service/cccr created

(레디니스 프로브확인)
> kubectl get pods
NAME                READY   STATUS    RESTARTS   AGE
cccr-44pmh          0/1     Running   0          35s
cccr-77kcv          0/1     Running   0          35s
cccr-jmsm2          0/1     Running   0          35s
cccr-liveness-pod   1/1     Running   1          21h
==> /var/ready 파일이 없기 때문에  READY 0/1로 준비되질 않을 것으 확인

(서비스 확인)
kubectl get services
NAME            TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
cccr            ClusterIP   10.109.218.253   <none>        80/TCP         106s
cccr-nodeport   NodePort    10.105.98.231    <none>        80:31111/TCP   125m
kubernetes      ClusterIP   10.96.0.1        <none>        443/TCP        2d2h

(엔드포인트 상태  확인)
> kubectl get endpoints cccr
NAME   ENDPOINTS   AGE
cccr               118s
==> ENDPOINTS 에 아무런 주소가 없음을 확인

(exec명령을 이용한 하나의 파드에 /var/ready 파일 생성)
> kubectl exec cccr-jmsm2 -- touch /var/ready

(파드의 준비상태와 엔드포인트 목록확인)
> kubectl get pods,endpoints
NAME                    READY   STATUS    RESTARTS   AGE
pod/cccr-44pmh          0/1     Running   0          3m6s
pod/cccr-77kcv          0/1     Running   0          3m6s
pod/cccr-jmsm2          1/1     Running   0          3m6s
pod/cccr-liveness-pod   1/1     Running   1          21h

NAME                      ENDPOINTS             AGE
endpoints/cccr            172.17.0.6:8080       3m6s
endpoints/cccr-nodeport   172.17.0.6:8080       126m
endpoints/kubernetes      192.168.99.100:8443   2d2h

==>> pod/cccr-jmsm2 의 READY 가  1/1 확인

(exec명령을 이용한 나머지의 파드에 /var/ready 파일 생성)
> kubectl exec cccr-44pmh -- touch /var/ready
> kubectl exec cccr-77kcv -- touch /var/ready


> kubectl get pods,endpoints
NAME                    READY   STATUS    RESTARTS   AGE
pod/cccr-44pmh          1/1     Running   0          3m55s
pod/cccr-77kcv          1/1     Running   0          3m55s
pod/cccr-jmsm2          1/1     Running   0          3m55s
pod/cccr-liveness-pod   1/1     Running   1          21h

NAME                      ENDPOINTS                                         AGE
endpoints/cccr            172.17.0.6:8080,172.17.0.7:8080,172.17.0.8:8080   3m55s
endpoints/cccr-nodeport   172.17.0.6:8080,172.17.0.7:8080,172.17.0.8:8080   127m
endpoints/kubernetes      192.168.99.100:8443                               2d2h

==>> READY 가  1/1 확인


** 헤드리스 서비스 ******************
주소 DB용으로 많이 사용, 즉, read/write용 pod와 read only용 pod를 관리할때 고정(rw), 동적할당(r) 할당 처치

(생성 )
yml작성 후 실행
> kubectl create -f cccr-headless-svc.yml
service/cccr-headless created

(헤드리스 서비스 확인)
> kubectl get services
NAME            TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
cccr            ClusterIP   10.109.218.253   <none>        80/TCP         9m57s
cccr-headless   ClusterIP   None             <none>        80/TCP         10s
cccr-nodeport   NodePort    10.105.98.231    <none>        80:31111/TCP   133m
kubernetes      ClusterIP   10.96.0.1        <none>        443/TCP        2d2h
==> cccr-headless   ClusterIP   None             <none>        80/TCP         10s 확인 됨.

(헤드리스 시비스 엔드포인트 목록 확인)
> kubectl get endpoints cccr-headless
NAME            ENDPOINTS                                         AGE
cccr-headless   172.17.0.6:8080,172.17.0.7:8080,172.17.0.8:8080   23s


(테스트용 파다를 생성해 서비스 주소 조회)
> kubectl run nettool -it --image=praqma/network-multitool --generator=run-pod/v1 --rm=true bash
If you don't see a command prompt, try pressing enter.
bash-5.0# nslookup cccr-headless
Server:         10.96.0.10
Address:        10.96.0.10#53

Name:   cccr-headless.default.svc.cluster.local
Address: 172.17.0.7
Name:   cccr-headless.default.svc.cluster.local
Address: 172.17.0.6
Name:   cccr-headless.default.svc.cluster.local
Address: 172.17.0.8

bash-5.0# nslookup cccr
Server:         10.96.0.10
Address:        10.96.0.10#53

Name:   cccr.default.svc.cluster.local
Address: 10.109.218.253

bash-5.0#

--------------------------------------------------------------------------------------------------------------------------------


7장 스토리지
***** 스토리지

** 볼륨
(종류)
-emptyDir
-getRepo
emptyDir기본 기능을 이용하여 초기에 Git리포지토리의 내용을 채워 제공하는 볼륨
많이 사용 안함.
-hostPath
쿠버네티스 클러스터 노드(호스트)의 파일 시스템을 제공하는 볼륨
다른 파드에서 접근 안됨, 그래서 테스트용으로 사용하지 실제로 사용안함
단, pod별 log용으로 활용가능하다.

-nfs
공유 스토리지로, NFS볼륨은 많이 사용

- 네트워크 스토리지 볼륨
cephfs, cinder, fc, iscsi, flexVolume, focker, glusterfs, quobyte, rbd, vsphereVolume, scaleIO 등
실습은 glusterfs으로...

==> pod가 직접연결하는 스토리지 :emptyDir, getRepo, nfs,네트워크 스토리지 볼륨


- awsElasticBlockStore, gcePersistentDisk, azureDis, azureFile등

- persistentVolumeClaim
정적/동적 프로비저님 볼륨
주로 개발자 연결 스토리지
(참고) 관리자는 PersistentVolume 리소스로 관리하고 개발자는 PersistentVolume에 연결(요청)하는 형태임.

- configMap, secret
특수 유형의 볼륨



** EmptyDir
임시저장 빈 볼륨
파드를 지우면 같이 사라짐,
메모리를 스로리지로 사용할 수 있음
sideCar 패턴 구현
-데이터 생성 컨테이너 + 데이터 손실 컨테이너 로 구현.




** hostPath

** PersistentVolume 및 PersistentVolumeClaim

** 정적볼륨


** 동적볼륨



 kubectl get pv
No resources found.
PS C:\education\02_kubernetes\work\03> code cccr-nfs-pv.yml
PS C:\education\02_kubernetes\work\03> code cccr-nfs-pv.yml
PS C:\education\02_kubernetes\work\03> kubectl create -f cccr-hostpaths-pv.yml
persistentvolume/cccr-nfs-pv created
PS C:\education\02_kubernetes\work\03> kubectl get psrsistentvolume
error: the server doesn't have a resource type "psrsistentvolume"
PS C:\education\02_kubernetes\work\03> kubectl get pv
NAME          CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE
cccr-nfs-pv   5Gi        RWX            Retain           Available                                   27s
PS C:\education\02_kubernetes\work\03> kubectl get persistentvolume
NAME          CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE
cccr-nfs-pv   5Gi        RWX            Retain           Available                                   39s
PS C:\education\02_kubernetes\work\03> kubectl create -f cccr-nfs-pvc.yml
persistentvolumeclaim/cccr-nfs-pvc created
PS C:\education\02_kubernetes\work\03>
PS C:\education\02_kubernetes\work\03>
PS C:\education\02_kubernetes\work\03> kubectl get pv .pvc
Error from server (NotFound): persistentvolumes ".pvc" not found
PS C:\education\02_kubernetes\work\03> kubectl get pv.pvc
error: the server doesn't have a resource type "pv"
PS C:\education\02_kubernetes\work\03> kubectl get pv,pvc
NAME                           CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                  STORAGECLASS   REASON   AGE
persistentvolume/cccr-nfs-pv   5Gi        RWX            Retain           Bound    default/cccr-nfs-pvc                           113s

NAME                                 STATUS   VOLUME        CAPACITY   ACCESS MODES   STORAGECLASS   AGE
persistentvolumeclaim/cccr-nfs-pvc   Bound    cccr-nfs-pv   5Gi        RWX                           29s
PS C:\education\02_kubernetes\work\03> kubectl get pv.pv
error: the server doesn't have a resource type "pv"
PS C:\education\02_kubernetes\work\03> kubectl get persistentvolumeclaims
NAME           STATUS   VOLUME        CAPACITY   ACCESS MODES   STORAGECLASS   AGE
cccr-nfs-pvc   Bound    cccr-nfs-pv   5Gi        RWX                           87s
PS C:\education\02_kubernetes\work\03> kubectl get persistentvolume
NAME          CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                  STORAGECLASS   REASON   AGE
cccr-nfs-pv   5Gi        RWX            Retain           Bound    default/cccr-nfs-pvc                           2m58s
PS C:\education\02_kubernetes\work\03> kubectl create -f cccr-nfs-rs.yml
replicaset.apps/cccr-nfs created
PS C:\education\02_kubernetes\work\03> kubectl get pods
NAME                  READY   STATUS              RESTARTS   AGE
cccr-44pmh            1/1     Running             0          125m
cccr-77kcv            1/1     Running             0          125m
cccr-hostpath-47wqb   1/1     Running             0          63m
cccr-hostpath-mkd7h   1/1     Running             0          63m
cccr-jmsm2            1/1     Running             0          125m
cccr-liveness-pod     1/1     Running             1          23h
cccr-nfs-7trkh        0/1     ContainerCreating   0          8s
cccr-nfs-tk6vj        0/1     ContainerCreating   0          8s
PS C:\education\02_kubernetes\work\03> kubectl describe pv cccr-nfs-pvc
Error from server (NotFound): persistentvolumes "cccr-nfs-pvc" not found
PS C:\education\02_kubernetes\work\03> kubectl describe pv cccr-nfs
Name:            cccr-nfs-pv
Labels:          <none>
Annotations:     pv.kubernetes.io/bound-by-controller: yes
Finalizers:      [kubernetes.io/pv-protection]
StorageClass:
Status:          Bound
Claim:           default/cccr-nfs-pvc
Reclaim Policy:  Retain
Access Modes:    RWX
VolumeMode:      Filesystem
Capacity:        5Gi
Node Affinity:   <none>
Message:
Source:
    Type:          HostPath (bare host directory volume)
    Path:          /web-contents
    HostPathType:  Directory
Events:            <none>

PS C:\education\02_kubernetes\work\03> kubectl describe persistentvolumeclaims cccr-nfs-pvc
Name:          cccr-nfs-pvc
Namespace:     default
StorageClass:
Status:        Bound
Volume:        cccr-nfs-pv
Labels:        <none>
Annotations:   pv.kubernetes.io/bind-completed: yes
               pv.kubernetes.io/bound-by-controller: yes
Finalizers:    [kubernetes.io/pvc-protection]
Capacity:      5Gi
Access Modes:  RWX
VolumeMode:    Filesystem
Mounted By:    cccr-nfs-7trkh
               cccr-nfs-tk6vj
Events:        <none>
PS C:\education\02_kubernetes\work\03> kubectl create -f cccr-nfs-svc.yml
service/cccr-nfs created
PS C:\education\02_kubernetes\work\03> kubectl run nettool -it --image=praqma/network-multitool --generator=run-pod/v1 --rm=true bash
If you don't see a command prompt, try pressing enter.

bash-5.0#
bash-5.0#
bash-5.0# curl http://cccr-nfs
curl: (7) Failed to connect to cccr-nfs port 80: Connection refused
bash-5.0# curl http://cccr-nfs
curl: (7) Failed to connect to cccr-nfs port 80: Connection refused
bash-5.0# exit
exit
Session ended, resume using 'kubectl attach nettool -c nettool -i -t' command when the pod is running
pod "nettool" deleted
PS C:\education\02_kubernetes\work\03> kubectl delete replicasets.apps cccr-nfs



kubectl delete persistentvolumeclaims cccr-nfs-pvc
persistentvolumeclaim "cccr-nfs-pvc" deleted
PS C:\education\02_kubernetes\work\03> kubectl create -f cccr-nfs-rs.yml
replicaset.apps/cccr-nfs created
PS C:\education\02_kubernetes\work\03> kubectl get sc
NAME                 PROVISIONER                AGE
standard (default)   k8s.io/minikube-hostpath   2d4h
PS C:\education\02_kubernetes\work\03> kubectl describe sc standard
Name:                  standard
IsDefaultClass:        Yes
Annotations:           storageclass.kubernetes.io/is-default-class=true
Provisioner:           k8s.io/minikube-hostpath
Parameters:            <none>
AllowVolumeExpansion:  <unset>
MountOptions:          <none>
ReclaimPolicy:         Delete
VolumeBindingMode:     Immediate
Events:                <none>
PS C:\education\02_kubernetes\work\03> minikube addons list
- addon-manager: enabled
- dashboard: disabled
- default-storageclass: enabled
- efk: disabled
- freshpod: disabled
- gvisor: disabled
- heapster: disabled
- ingress: enabled
- logviewer: disabled
- metrics-server: disabled
- nvidia-driver-installer: disabled
- nvidia-gpu-device-plugin: disabled
- registry: disabled
- registry-creds: disabled
- storage-provisioner: enabled
- storage-provisioner-gluster: disabled
PS C:\education\02_kubernetes\work\03> kubectl get storageclass
NAME                 PROVISIONER                AGE
standard (default)   k8s.io/minikube-hostpath   2d4h
PS C:\education\02_kubernetes\work\03> minikube addons enable storage-provisioner-gluster
* storage-provisioner-gluster was successfully enabled
PS C:\education\02_kubernetes\work\03> minikube addons list
- addon-manager: enabled
- dashboard: disabled
- default-storageclass: enabled
- efk: disabled
- freshpod: disabled
- gvisor: disabled
- heapster: disabled
- ingress: enabled
- logviewer: disabled
- metrics-server: disabled
- nvidia-driver-installer: disabled
- nvidia-gpu-device-plugin: disabled
- registry: disabled
- registry-creds: disabled
- storage-provisioner: enabled
- storage-provisioner-gluster: enabled
PS C:\education\02_kubernetes\work\03> kubectl get ns
NAME                STATUS   AGE
default             Active   2d4h
development         Active   24h
kube-node-lease     Active   2d4h
kube-public         Active   2d4h
kube-system         Active   2d4h
quality-assurance   Active   24h





8장 애플리케이션 사용자화 **********************
서비스 설정파일, 환경파일 민감한 비밀번호 등 설정

**컨테이너 애플리케이션 사용자화*******

**인자 및 인자 사용자화*******

>  kubectl create -f cccr-arg-pod.yml
pod/cccr-arg-pod created
\> kubectl port-forward cccr-arg-pod 8080:8080
Forwarding from 127.0.0.1:8080 -> 8080

별도 command창에서 실행
 > curl http://localhost:8080

Forwarding from [::1]:8080 -> 8080
Handling connection for 8080



**환경변수를 이용한 사용자화*******

**컨피그 맴*******
많이 사용 중요함.
kubectl get configmap
No resources found.
PS C:\education\02_kubernetes\work\03> kubectl get cm
No resources found.
PS C:\education\02_kubernetes\work\03> kubectl create configmap my-config1 --from-literal=key1=value1
configmap/my-config1 created
PS C:\education\02_kubernetes\work\03>
PS C:\education\02_kubernetes\work\03>
PS C:\education\02_kubernetes\work\03> kubectl get cm
NAME         DATA   AGE
my-config1   1      8s
PS C:\education\02_kubernetes\work\03> kubectl describe cm my-config1
Name:         my-config1
Namespace:    default
Labels:       <none>
Annotations:  <none>

Data
====
key1:
----
value1
Events:  <none>


(key2 작성 )
echo value2 > key2

> cat .\key2
value2

> kubectl create cm my-config2 --from-file=.\key2
configmap/my-config2 created

> kubectl get cm
NAME         DATA   AGE
my-config1   1      2m46s
my-config2   0      5s


> kubectl describe cm my-config2
Name:         my-config2
Namespace:    default
Labels:       <none>
Annotations:  <none>

Data
====
Events:  <none>






**시크릿*******
컨피그 맴와 같은 key/value 값 저장
base64인코딩 저장,

> kubectl get secret
NAME                  TYPE                                  DATA   AGE
default-token-fx2tj   kubernetes.io/service-account-token   3      2d22h
ingress-tls-secret    kubernetes.io/tls                     2      20h


> kubectl describe secret default-token-fx2tj
Name:         default-token-fx2tj
Namespace:    default
Labels:       <none>
Annotations:  kubernetes.io/service-account.name: default
              kubernetes.io/service-account.uid: 9af3ac41-f622-4264-a2e4-a468ccc88f4a

Type:  kubernetes.io/service-account-token

Data
====
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImRlZmF1bHQtdG9rZW4tZngydGoiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGVmYXVsdCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjlhZjNhYzQxLWY2MjItNDI2NC1hMmU0LWE0NjhjY2M4OGY0YSIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZmF1bHQifQ.LiCKB3V_S1R2gpqTvBhKsKuUu4lJ8PnGz6f7HRqbgDR7bze_5zbH2M2MiMvkUHJIisgxHI5Gg78pCg6i4x5dGoUAxIG6F51wfhcVxxZBK7XBmVyGt4lpUcnXs3mhoP4L1GgPkRjKreWLTPTS56uUZjmUd_RrCuFZzGaV2rmR6w3LQEzUxeMOwSHxd6ovGG-ML93e8JaAYV_sVEmGgXMNN9ScUTZpOobNHB6lxsLJJfEsBctxfNM4iU-nq3nysS1ti1_wflvecAPUShkuldM8MDaguurbO9ED4q4wZYLHIxWrdX0LshulLuUjJZR9BIylPMzMjpuNphtVG1K77gFJmQ
ca.crt:     1066 bytes
namespace:  7 bytes


> kubectl describe pod coredns-5c98db65d4-4ntms
==> Mounts: 
     /var/run/secrets/kube~~~

*****시크릿이용 이용한 HTTPS 웹서비스 제공
(1) TLS 키 및 인증서 생성

(2) 시크릿 생성
> kubectl create secret generic nginx-tls-secret --from-file=nginx-tls.key --from-file=nginx-tls.cert
secret/nginx-tls-secret created

(확인)
> kubectl describe secrets nginx-tls-secret
Name:         nginx-tls-secret
Namespace:    default
Labels:       <none>
Annotations:  <none>

Type:  Opaque

Data
====
nginx-tls.cert:  997 bytes
nginx-tls.key:   1675 bytes

(3) TLS를 위한 Nginx 설정 파일 및 컨피그 맵 생성
(TLS를 사용하기 위한 Nginx 설정 파일 생성)
tls-nginx.conf

(설정 파일을 컨피그 맵에 생성)
> kubectl create configmap tls-nginx-config --from-file=tls-nginx.conf
configmap/tls-nginx-config created

(컨피그맵 확인)
> kubectl describe configmap tls-nginx-config
Name:         tls-nginx-config
Namespace:    default
Labels:       <none>
Annotations:  <none>

Data
====
tls-nginx.conf:
----
server {
    listen              80;
    listen    443 ssl;
    server_name         cccr.example.com;
    ssl_certificate      /etc/nginx/ssl/nginx-tls.cert;
    ssl_certificate_key  /etc/nginx/ssl/nginx-tls.key;
    ssl_protocols        TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers            HIGH:!aNULL:!MD5;
    location / {
        root   /usr/share/nginx/html;
        index  index.html;
    }
}

Events:  <none>

(4) 시크릿 및 컨피그 맵을 사용하는 파드 생성
(yml작성 및 생성 )
> kubectl create -f cccr-https-pod.yml
pod/cccr-https created

(파파다의 상세정보를 확안히여 볼륨이 제대로 연결되었는지 확인)
> kubectl describe pod cccr-https
Name:         cccr-https
Namespace:    default
Priority:     0
Node:         minikube/10.0.2.15
Start Time:   Thu, 18 Jul 2019 09:58:51 +0900
Labels:       <none>
Annotations:  <none>
Status:       Running
IP:           172.17.0.19
Containers:
  cccr-https:
    Container ID:   docker://3ac67fc60184d869a483d66eae18618ae66a6d4f4f50726a40c3edb2530ef4ec
    Image:          nginx
    Image ID:       docker-pullable://nginx@sha256:b4b9b3eee194703fc2fa8afa5b7510c77ae70cfba567af1376a573a967c03dbb
    Ports:          80/TCP, 443/TCP
    Host Ports:     0/TCP, 0/TCP
    State:          Running
      Started:      Thu, 18 Jul 2019 09:59:02 +0900
    Ready:          True
    Restart Count:  0
    Environment:    <none>
    Mounts:
      /etc/nginx/conf.d from nginx-config (rw)
      /etc/nginx/ssl from https-cert (ro)
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-fx2tj (ro)
Conditions:
  Type              Status
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
Volumes:
  nginx-config:
    Type:      ConfigMap (a volume populated by a ConfigMap)
    Name:      tls-nginx-config
    Optional:  false
  https-cert:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  nginx-tls-secret
    Optional:    false
  default-token-fx2tj:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-fx2tj
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  <none>
Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                 node.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  14s   default-scheduler  Successfully assigned default/cccr-https to minikube
  Normal  Pulling    13s   kubelet, minikube  Pulling image "nginx"
  Normal  Pulled     4s    kubelet, minikube  Successfully pulled image "nginx"
  Normal  Created    4s    kubelet, minikube  Created container cccr-https
  Normal  Started    3s    kubelet, minikube  Started container cccr-https

==> 위 결과 중 Mounts:내용 확인
-------------------------------------------------------------------
  Mounts:
      /etc/nginx/conf.d from nginx-config (rw)
      /etc/nginx/ssl from https-cert (ro)
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-fx2tj (ro)
-------------------------------------------------------------------      

> kubectl port-forward cccr-https 8443:443
Forwarding from 127.0.0.1:8443 -> 443
Forwarding from [::1]:8443 -> 443


(확인)
> curl https://localost:8443 -k -v 
==> -k 옵션은 https통신 필수 








제 9장 디플로이먼트 **********************************************

1) 레플리케이션 컨트롤러 롤링 업데이터

2) 디플로이먼트
(중요)

(참고)
kubectl describe deploy cccr
==> 내용중 
	MinReadySeconds: 0 <== 만들고/삭제하고 시간,
	RollingUpdateStrategy : 25% max unavailable, 25% max surge 
   -> 삭제되고, 생성되고 하는 %

> kubectl explain Deployment
> kubectl explain Deployment.spec.strategy.type




제 10장 스테이트풀셋 ******************************************************
db와 같은 data를 저장 관리할때 적합한 컨트롤러 
각 pod마다 별도의 스토리지를 필요할때

1) 스테이트풀셋 소개

2) 스테이트풀셋 관리


(참고)

yaml 파일내 2개 문서 작성시 -- 으로 구분될 수 있음





제 11장 오토스케일링 ****************************************************************

1) 파드의 리소스 관리
Request: 파드에 필요한 최소 리소스
Limit: 해당 pod릐 최대 한계치 

아래 2개를 활성화 해야 함
minikube addons enable heapster		  <= 웹인터페이스 모니터일할 수 있는 대시보드(현재 deplicate 상태, 더 이상 개발하질 않므)
결과메시지:* heapster was successfully enabled
minikube addons eanble metrics-server <= 사용한 확인만 하며 저장하지는 않음

(minikube의 nodes 상태확인)
> kubectl top nodes minikube
NAME       CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%
minikube   453m         22%    1567Mi          54%
(참고) 1000m cores는 1CPU core임.
> kubectl get po
> kubectl top po nettool <= nettool상태 확인

(yaml작성 후 생성 - requests)
> kubectl create -f cccr-requests-pod.yml

(현재 파드의 리소스 사용량 확인)
> kubectl top pod requests-pod
NAME           CPU(cores)   MEMORY(bytes)
requests-pod   0m           5Mi

(사용량 실시간 모니터링)
while (1) {kubectl top pod requests-pod; start-sleep -seconds: 1; clear} 

> kubectl describe node minikube
==> 결과호면
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
--

Conditions:
  Type             Status  LastHeartbeatTime                 LastTransitionTime                Reason                       Message
  ----             ------  -----------------                 ------------------                ------                       -------
  MemoryPressure   False   Thu, 18 Jul 2019 13:48:25 +0900   Mon, 15 Jul 2019 11:24:19 +0900   KubeletHasSufficientMemory   kubelet has sufficient memory available
  DiskPressure     False   Thu, 18 Jul 2019 13:48:25 +0900   Mon, 15 Jul 2019 11:24:19 +0900   KubeletHasNoDiskPressure     kubelet has no disk pressure
  PIDPressure      False   Thu, 18 Jul 2019 13:48:25 +0900   Mon, 15 Jul 2019 11:24:19 +0900   KubeletHasSufficientPID      kubelet has sufficient PID available
  Ready            True    Thu, 18 Jul 2019 13:48:25 +0900   Mon, 15 Jul 2019 11:24:19 +0900   KubeletReady                 kubelet is posting ready status

---

Non-terminated Pods:         (29 in total)
  Namespace                  Name                                         CPU Requests  CPU Limits  Memory Requests  Memory Limits  AGE
  ---------                  ----                                         ------------  ----------  ---------------  -------------  ---
  default                    cccr-44pmh                                   0 (0%)        0 (0%)      0 (0%)           0 (0%)         24h

--

Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  Resource           Requests     Limits
  --------           --------     ------
  cpu                1075m (53%)  20m (1%)
  memory             330Mi (11%)  370Mi (12%)
  ephemeral-storage  0 (0%)       0 (0%)
---  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

==> (참고)metrics-server enable해야함 보임



(limits : 제한)
spec: 지시어의 
  resources: 
    limits:
      cpu: 0.5
      memory: 20Mi
==> limits 제한(cpu 0.5core, 메모리 20M)

> kubectl create -f cccr-limits-pod.yml
> kubectl describe po cccr-limits-pod
(부하 테스트)
> kubectl exec limits-pod -- md5sum /dev/zero
> 또는 bash접속후 : /dev/zero&

**LimitRange*****
위 생성은 파드 생성시 설정이나
LimitRange 사용으로 컨트롤러 및 파드 생성할때 마다 기본 제한 설정으로 자동으로 제한을 할 수 있다.
==> 기본 제한 설정상태에서 pod 생성시 제한 범위를 벗어나 생성되질 않음


***ResourceQuota(네임스페이스 리소스쿠터)
LimitRange는 컨트롤러와 파드에만 설정할 수 있으나 리소스쿼터을 이용하면 네임스페이스 레벨에서 쿼터를 제한 할 수 있다.
-cpu 및 메모리쿼터, 오브젝트 쿼터, 스토리지 쿼터 등 
(조회)
> kubectl get resourcequota



kubectl port-forward service/heapster 8080:80 -n kube-system
Forwarding from 127.0.0.1:8080 -> 8082
Forwarding from [::1]:8080 -> 8082

> kubectl get all -n kube-system <==서비스 조회 후 내용중 service가 NodePort를 확인 후
--생략 
service/monitoring-grafana     NodePort    10.98.131.98   <none>        80:30002/TCP             39m
--생략 --
브라우져로 접속하여 모니터링 가능 
http://192.168.99.100:30002/?orgId=1

2) 파드 수평적 오토스케일링(HPA)
HPA 동작 3가지 단계
-관리되는 모든 파드의 메트릭(예:CPU사용량 등 하드웨어)을 측정해 가져온다.
-지정한 목표 값에 부합하도록 필요한 파드 수 계산
-파드를 관리하는 컨트롤러의 복제본을 조정.

레플리케이션 컨트롤러
YAML
apiVersion: autoscaling/v2beta1
kind: HorizontalPodAutoscaler

(1)파드의 메트릭 가져오기

(2)파드 수 계산
cpu와 메모리만 계산,
참고로 이외는 [프로메테우스] 등 오픈소스를 활용하게 계산해야 함.



(3)복제본 수 조정

(4)














=========================================================

******vagrant***************************************************
https://www.vagrantup.com/

쿠버네티스 Master 메모리: 1500을 넘어야 한다.


(vagrant 설치)
> choco install vagrant

(ubuntu/bionic62 설치 )
> vagrant init ubuntu/bionic62
> vagrant up <=해당 디렉코리내 vagrant file을 찾아 실행됨.


