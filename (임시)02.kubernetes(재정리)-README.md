# 쿠버네티스 명령어 모음


## 1. Pod
1) Pod 기본 명령어 
(0) 파드생성
kubect create -f <yaml파일명(예:sample.yml)>

(1)pod 목록조회
kubectl get pods

(2)실행중읜 파드의 정의 확인 
kubectl get pods <파드명> -o -yml(error 발생시, yaml 또는 json)

(3) 파드이 상세정보 확인 
kubectl describe pods <파드명>

(4) 파드 로그 확인
kubectl logs <파드명>
kubectl logs <파드명> -c <컨테이너명> <==다중 컨테이너를 가지고 있는 파드의 경우

(5) 파드 포트 포워딩
kubectl port-forward <파드명> 8080:8080

(6) 불필요한 모든 파드 삭제
kubectl delete pods --all


2) Label
-쿠버네티스 클러스터의 모든 오브젝트에 키/값 형태로 리소스 식별하고 속성을 지정하는데 사용.
(1)파드의 라벨확인
kubectl get pods --show-labels
kubectl get pods -L <라벨1,라벨2>(예: env,tier) <== -L: 특정 라벨을 지정하여 표시
kubectl get pods --show-labels -l tier <==tier키가 있는 라벨 파드 조회
kubectl get pods --show-labels -l '!tier'  <== tier키가 아닌 라벨 파드 조회 
kubectl get pods --show-lables -l env=debug <= env키 값이 debug인 라벨 파드 조회
kubectl get pods --show-labels -l 'env in (debug,dev)'

(2)라벨수정
kubectl label pods <파드명> <라벨키=라벨값>
kubectl label pods <파드명> <라벨키=라벨값> --overwrite <==--overwrite: 기존 라벨값이 있을 경우

3) 어노테이션 
주석이라고도 하며 오브젝트에 메타데이터를 첨부 할 수 있음.
보통 개발자 정보, 디버깅 정보 등
(1)어노테이션 생성
kubectl annotate pods <파드명> <어노테이션키=어노테인션값>
예) kubectl annotate pods cccr-pod devops-team/developer="홍길동"

(2)어노테이션 확인 
어노테이션 확인은 kubectl describe 명령을 확인
=> kubectl describe pods cccr-pod 
조회 내용중 에 Annotations: 있음
...
Annotations: devops-team/developer: 홍길동
...

kubectl get pods cccr-pod -o -yml 으로도 확인 가능


4) 네임스페이스
오브젝트를 논리적으로 분리할 수 있는 논리 파티션
오브젝트를 관리할때 논리 적으로 오브젝트를 분리할때 사용.
팀별 개발, QA, 프로덕션 등 필요한 용도별로 오브젝트를 분리가 필요할때

(1)네임스페이스 생성
(명령어로 생성)
kubectl create namespace <네임스페이스지정>
> kubectl create namespace development

(YAML 파일로 지정)
apiVersion: v1
kind: Namespacevo
--생략--
metadata:
  name: development-yaml
==> kind에 Namespacevo로 네임스페이스로 정의 후 metatata: 의 name에 네임스페이지 저정

(특정 네임스페이스에서 오브젝트 생성)
kubectl create -f <yaml파일> -n <네임스페이스>
> kubectl create -f sample.yml -n sample-namespace <== 파드 생성시 sample-namespace 라는 네임스페이지 지정
> kubectl get pods -n sample-namespace <== sample-namespace의 pods 조회 확인

(위 내용을 yaml문서 작성시)
apiVersion: v1
kine: Pod
metadata: 
  name: sample-pod
  namespace: sample-namespace
-- 생략 --
==> sample-namespace이라는 네임스페이를 갖는 sample-pod라는 이름의 pod를 생성


(2)네임스페이스 확인
> kubectl get namespaces
(참고) 오브젝트(파드 포함) 생성시 네임스페이스를 지정하질 않으면 default가 지정됨.
=> 목록 NAME에 위에서 생성한 development 확인

(3)네임스페이스 오브젝트 확인
(kube-system 네임스페이스에 존재하는 파드의 목록을 확인하는 명령)
> kubectl gt pods -n kube-system

(4)오브젝트(Pod 및 네임스페이스) 삭제
(오브젝트 이름으로 파드삭제)
kubectl delete pods <파드명>
> kubectl delete pods sample-pod

(YAML 파일로 파드 삭제)
kubectl delete -f sample.yml
==> yaml 문서에 정의 된 네임스페이스+파드명의 pod가 삭제됨

(오브젝트 라벨을 이용한 오브젝트 삭제)
> kubectl delete pods -l env=dev
==> default 네임스페이스에서 env=dev 라벨을 가지고 있는 모든 오브젝트 삭제.

(5) 네임스페이스 삭제
(명령어로 삭제)
kubectl delete namespace <네임스페이스명>
> kubectl delete namespace development

(YAML 파일로 삭제)
kubectl delete -f <YAML파일명>
> kubectl deleft -f sample.yml


kubectl create -f ***.yml

kubectl get pvc,pv


===========================================================================================================================================

## 2. 워크로드-컨트롤러
중요한 기능
1) 라이브니스 프로브(Liveness Probe)
파드에 의해 컨테이너가 동작하게 되고, 동작하고 있는 컨테이너가 잘 동작하는지 주직적으로 모니터링하며
만약 모니터링 도중 장애 발생시 해당 커네이너를 다시 시작하게 함.
-HTTP GET 프로브: 주로 웹서비스 
-TCP 소켓 프로브: 특정 TCP 포트 연결 시도 함.
-Exec 프로브: 네트워크 서비스가 아닌 경우에 명령어로 관리
(1) 생성
YAML파일 작성시 livenessProbe 지시어를 사용하여 아래 형식으로 작성
--생략--
spec:
  containers:
  - livenessProbe:
    httpGet:
    tcpSocket:
    exec:
--생략--

(sample.yml)
--생략--
spec:
  containers:
  --생략-
  ports:
  - containerPort: 8080
    protocal: TCP
  - livenessProbe:
    httpGet:
      path: /
      port: 8080
--생략--
==> HTTP GET 프로브를 사용하였으며 경로는 /, 포트는 8080지정
==> 만약 containerPort 와 httpGet port가 틀리면 모니터링이 되질 않는다.
(참고) kubectl explain pod.spec.containers.livenessProbe


(yml문서기반으로 생성)
> kubectl create -f sample.yml

(2) 파드를 주기적으로 확인
> kubectl get pods --watch
(참고) 리눅스 실시간(1초간격) 모니터링 명령어
> while (1) {kubectl get pods; start-sleep -seconds: 1; clear}


(3)라이브니스 상태 확인
> kubectl get pods --watch




2) 레플리케이션 컨트롤러( replicationcontrollers:rc)
파드가 특정 개수만큼 복제되고 동작하는 것을 보장
원하는 수의 복제본 보다 더 많이 복제본이 많아 질 수 있다.
(1) 레플리케이션 컨트롤러 생성
(yml작성 후 생성)
> kubectl create -f sample-replicationcontoller.yml

(2) 레플리케이션 컨트롤러 확인
> kubectl get replicationcontrollers
> kubectl get pods <= 위 명령수행후 pod 목록 갯수 확인

> kubectl get pods --show-labels <== labes단위까지 확인

> kubectl get replicationcontrollers
==> 위 pod가 요구복제본 개수만큼  생성된 것으 확인후 다시 실행시 replicationcontrollers 자세한 정보 확인됨.

> kubectl describe replicationcontrollers cccr
==> 어떤 파드가 생성 되었는지 등 정보 확인 가능


(3) 레플리케이션 컨트롤러와 라벨
레플리케이션 컨트롤러는 관리할 파드를 라벨과 레플리케이션 컨트롤러의 라벨 셀렉터를 이용하여, 관리할 파드를 지정하고 관리함.
> kubectl get pods --show-labels
--생략--
sample-pod-xxx    1/1    Running   0   21m   aap=sample-pod
--생략--

(라벨 추가: smaple-pod-xxx 파드에 env=dev)
> kubectl label pods sample-pod-xxx env=dev 

> kubectl get pods --show-labels
--생략--
sample-pod-xxx    1/1    Running   0   21m   aap=sample-pod,env=dev
--생략--
==>env=dev 라벨이 추가된 것 확인

(라벨 변경)
> kubectl label pods sample-pod-xxx env=test --overwrite
==>라벨 변경시 레플리케이션 컨트롤러는 관리하는 라벨이 없으므로 관리하질 않고 새로운 파드를 생성한다.


(4) 파드의 수평 스케일링
복제본 수를 변경하여 수평 스케일링

(명령을 이용항 스케일잉)  
kubectl scale replicationcontroller <레플리케이션 컨트롤러 이름> --replicas=4
==> kubectl get rc(replicationcontrollers)에서 확인한 Name(이름)

> kubectl scale replicationcontroller cccr --replicas=4

(cccr 레플리케이션 컨트롤러의 상태확인(복제수4))
> kubectl get rc(replicationcontrollers
(파드목록확인)
> kubectl get pods
> kubectl get pods --show-labels

(5)레플리케이션 컨트롤러 및 파드 삭제
레플리케이션 컨트롤러에 관리되는 파드는 삭제해도 복제본이 생성된다.
그래서 파드를 삭제할려면 컨트롤러를 직접 삭제해야 해당 관리되는 파드도 삭제됨.
> kubectl delete rc cccr <==rc:replicationcontrollers

(삭제후 레플리케이션 컨트롤러와 파드 삭제여부 확인)
> kubectl get rc
> kubectl get pods


3) 레플리카셋 *******
- 레플리케이션 컨트롤러의 기능개선 버전으로 실제 많이 사용
레플리케이션 컨트롤러보다 개선된 기능: 파드이 다중 라벨지원, 파드에 설정된 라벨의 키만 선택가능

(1) 레플리카셋 생성
레플리카셋 오브젝트 API 버전: apps/v1beta2
> kubectl api-resources
> kubectl api-version
YAML 파일
-------------------------
apiVersion: apps/v1beta2
kind: ReplicaSet
-------------------------

(레플리카셋의 라벨셀렉터)
kubectl explain replicaset.spec.selector

(2) 레플리카셋 생성
> kubectl create -f sample-replicaset.yml

(레플리카셋 확인)
> kubectl get replicasets.apps
(파드 목록 확인)
> kubectl get pods <==sample-replicase.yml에 정의 된  replicas: 3 개수 정상생성 확인

(3) 레플리카셋 라벨셀렉터 사용
(matchLabels 라벨셀렉터)
matchExpressions 라벨셀렉터는 반드시 YAML의 리스트로 표현해야 함
(형식)
--생략--
spec:
  selector:
    matchExpressions:
      - key: <string>
        operator: <In| NotIn | Exists | DoesNotExist>
        values:
        - <String>
--생략--

==>matchExpressions 지시어가 레플리카셋의 추가 기능, and 조건

(샘플: app:cccr and env:) <= 라벨셀렉터는 app키가 cccr이고, env키가 존재하며 env에 대한 값은 유/무에 상관없음.
--생략--
spec:
  selector:
    matchExpressions:
      - key: app
        operator: In
        values:
        - cccr
      - key: env
        operator: Exists <==Exists는 라벨의 키가 포함되야하고 값은 상관없음
--생략--

(4) 레플리카셋 확인
> kubectl get replicasets.apps -o wide
==> 컨트롤러의 SELECTOR필드 확인

> while (1) {kubectl get replicasets.apps  -o wide; start-sleep -seconds: 1; clear}


(레플리카셋 컨트롤러에 의해 생성된 파드 목록확인)
> kubectl get pods --show-labels





4) 데몬셋

5) 잡
애플리케이션이 실행되고 실행이 완료되면 파드이 할일 끝난 것으로 간주하고 파드를 종료시키는 것으로 임시(Ad-hoc) 작업에 유용함.
오브젝트 API: batch 그룹의 v1 버전 사용, 오브젝트 종류는 Job
apiVersion: batch/v1
kind: Job

> kubectl create -f sample-job.yml

> kubectl get jobs.batch

> kubectl get pods

> kubectl get jobs.batch

(직렬 다중잡)
지시어중: completions: 3
> kubectl get jobs.batch

(병렬 다중 작업생성)
spec: 
  completions: 3
  parallelism: 3
> kubtctl create -f sample-multi-comp-parallel-job.yml

> kubectl get jobs.batch

> kubectl get jobs.batch



6) 크론잡
잡은 한번한 실행되지만, 크론잡은 주기적으로 실행할 때 사용하는 컨트롤러(리눅스의 cronjob와 같은 기능)

spec:
  schedule: "*/2 * * * *"
  jobTemplate:

==> "*/2 * * * *"   별 5개의 의미는 분 시 일 월 요일(0-일요일, 1-월요일, 6-토요일)
==> */2 : 2분마다 실행하라!!

(생성)
> kubectl create -f sample-cronjbo.yml

(확인)
> kubectl get cronjbos.batch
==> 최초 생성 후 활성화된(ACTIVE), 마지막 동작한 작업(LAST SCHEDULE) 작업은 없으며, 약 2	분후에 최초의 작업이 실행된 것을 확인.
> kubectl get pods
==> 파드가 실행되었고 약 1분후 완료된 것을 확인.
> kubectl get cronjbos.batch <= 파드생성 확인후 실행하면 LAST SCHEDULE 값에 마지막 시간이 표시된다.






===========================================================================================================================================


## 3. 네트워크
쿠버테티스를 설치하면 칼리코(Calico) 네트워크가 설치됨.
파드와 클러스터 들 간의 연결(통신,응답) 역할??



1) 서비스
같은 애플리케이션을 실행하고 있는 파드의 그룹에 단일 네트워크 진입점을 제공하는 리소스.
서비스에 부여된 IP는 해당 서비스가 종료될때 까지는 변경되질 않음.

클라이언트는 서비승서 제공하는 고정IP 또는 포트를 통해 pod에 접근



**** 환경변수 탐색
kubectl exec sample-****(파드명) env


** 서비스 탐색***********************************
-web <-> was <-> db 서비스 탐색 연결
--> 서비스 참조로 가능 
(2)DNS를 이용한 서비스 검색
> kubectl get all -n kube-system -l k8s-app=kube-dns
-----------------------------------------------------------------------------------------------
NAME                           READY   STATUS    RESTARTS   AGE
pod/coredns-5c98db65d4-4ntms   1/1     Running   5          47h
pod/coredns-5c98db65d4-7dql7   1/1     Running   5          47h


NAME               TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE
service/kube-dns   ClusterIP   10.96.0.10   <none>        53/UDP,53/TCP,9153/TCP   47h


NAME                      READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/coredns   2/2     2            2           47h

NAME                                 DESIRED   CURRENT   READY   AGE
replicaset.apps/coredns-5c98db65d4   2         2         2       47h
-----------------------------------------------------------------------------------------------
파드의 내부 DNS설정도 확인 가능
> kubectl exec cccr-ww444 cat /etc/resolv.conf
nameserver 10.96.0.10
search default.svc.cluster.local svc.cluster.local cluster.local
options ndots:5




(1)서비스 생성
(명령을 이용하는 방법)
kubectl expose <CONTROLLER_TYPE> <RESOUCE> [--type=SVC_TYPE] --name <NAME>
> kubectl expose rc sample-app --type=LoadBalancer --name=sample-svc
service "cccr-svc" exposed

(YAML 파일을 이용하는 방법)
sample-svc.yml
--------------------------------------------------
apiVersion: v1
kind: Service
metadata:
  name: sample
spec:
  ports:
  - port: 80 # 서비스 포트
    targetPort: 8080 # 파드 포트
  selector:
    app: sample # 파드 라벨셀렉터
--------------------------------------------------
> kubectl create -f sample-svc.yml











































(2) 서비스 및 엔드포인트 확인
(서비스 목록 확인)
> kubectl get services <= svc 약어
NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
sample-svc   LoadBalancer   10.100.20.190   <pending>     8080:32559/TCP   27s
kubernetes   ClusterIP      10.96.0.1       <none>        443/TCP          1d

* EXTERNAL-IP pending 상태인데.. 이는 외부 로드밸런서가 없어서 외부 IP를 얻지 못해서... minikube에서는 아래 명령으로 사용하면 됨.
> minikube.exe tunnel

* 위 명령 error발생이 아래 명령으로 실행후 브라우져 확인 
> minikube.exe service list
|-------------|------------|-----------------------------|
|  NAMESPACE  |    NAME    |             URL             |
|-------------|------------|-----------------------------|
| default     | sample-svc | http://192.168.99.100:32559 |
| default     | kubernetes | No node port                |
| kube-system | kube-dns   | No node port                |
|-------------|------------|-----------------------------|

> minikube.exe service sample-svc
* Opening kubernetes service default/cccr-svc in default browser...


(엔드포인트 확인)
> kubectl get endpoints
NAME        ENDPOINTS             AGE
sample                            3m6s


(엔드포인트 상태  확인)
> kubectl get endpoints sample
NAME   ENDPOINTS   AGE
sample             118s
==> ENDPOINTS 에 아무런 주소가 없음을 확인

(exec명령을 이용한 하나의 파드에 /var/ready 파일 생성)
> kubectl exec sample-jmsm2 -- touch /var/ready <==sample-jmsm2: pod이름 smaple-램덤값자동지정


(파드의 준비상태와 엔드포인트 목록확인)
> kubectl get pods,endpoints
NAME                      READY   STATUS    RESTARTS   AGE
pod/sample-44pmh          0/1     Running   0          3m6s
pod/sample-77kcv          0/1     Running   0          3m6s
pod/sample-jmsm2          1/1     Running   0          3m6s
pod/sample-liveness-pod   1/1     Running   1          21h

NAME                      ENDPOINTS             AGE
endpoints/sample            172.17.0.6:8080       3m6s
endpoints/sample-nodeport   172.17.0.6:8080       126m
endpoints/kubernetes        192.168.99.100:8443   2d2h

==>> pod/cccr-jmsm2 의 READY 가  1/1 확인

(exec명령을 이용한 나머지의 파드에 /var/ready 파일 생성)
> kubectl exec cccr-44pmh -- touch /var/ready
> kubectl exec cccr-77kcv -- touch /var/ready


> kubectl get pods,endpoints
NAME                    READY   STATUS    RESTARTS   AGE
pod/cccr-44pmh          1/1     Running   0          3m55s
pod/cccr-77kcv          1/1     Running   0          3m55s
pod/cccr-jmsm2          1/1     Running   0          3m55s
pod/cccr-liveness-pod   1/1     Running   1          21h

NAME                      ENDPOINTS                                         AGE
endpoints/cccr            172.17.0.6:8080,172.17.0.7:8080,172.17.0.8:8080   3m55s
endpoints/cccr-nodeport   172.17.0.6:8080,172.17.0.7:8080,172.17.0.8:8080   127m
endpoints/kubernetes      192.168.99.100:8443                               2d2h

==>> READY 가  1/1 확인


(서비스 접근 테스트)
> kubectl run nettool -it --image=praqma/network-multitool --generator=run-pod/v1 --rm=true bash
If you don't see a command prompt, try pressing enter.
> bash-5.0#

==> --generator=run-pod/v1: 옵션을 지정하질 않으면 기본적으로 디폴리먼트 오브젝트로 파드를 생성함.

> bash-5.0# curl http:/10.100.20.190 <== 접근시 마다 부하 분산(접근 서비스 파드가 바뀌는 것)을 볼 수 있다.

(서비스 세션 친환성 구성)
클라이언트가 요청 매번 똑같은 파드로 연결하고 싶은 경우

(서비스 다중포드 구성)
예로 http:80, https:443 등 구성시
-------------------------------------------------------
apiVersion: v1
kind: Service
metadata:
  name: sample
spec:
  ports:
  - name: sample-http
    port: 80
    targetPort: 8080
  - name: sample-https
    port: 443
    targetPort: 8443
  selector:
    app: sample
-------------------------------------------------------


(포트 이름 참조)
파드(컨테이너)의 포트 이름을 이용하시 서비스 생성시 파드의 대상(targetPort)에 이름을 이용하여 연결
targetPort의 값을 포트 이름 으로 지정시 Replicaset의 containerPort: 8080으로 연결됨.
ReplicaSet
-------------------------------------------------------
apiVersion: apps/v1beta2
kind: ReplicaSet
metadata:
  name: sample
spec:
  replicas: 3
  -- 생략 --
  spec:
    containers:
    - name: sample
      image: ons/httpd
      ports:
      - name: sample-http
        port: 80
        containerPort: 8080
  selector:
    app: sample
-------------------------------------------------------

Service
-------------------------------------------------------
apiVersion: v1
kind: Service
metadata:
  name: sample
spec:
  ports:
  - name: sample-http
    port: 80
    targetPort: sample-http # 8080포트 대신에 sample-http이름으로 지정
  selector:
  app: sample
-------------------------------------------------------

(오브젝트 확인)
-레플리카셋 컨트롤러를 확인
> kubectl get replicasets.apps

> kubectl get endpoints sample

> kubectl get pods -o wide


(포트변경 및 확인)




(2) 서비스 탐색







-NodePort : 외부노출용


2) 인그레스

3) 레디니스 프로브


4) 헤드리스 서비스




===========================================================================================================================================
